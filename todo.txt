- The channel owner is a channel administrator. They can set other users as administrators.


- before add users who want to be administrators:

=>  chcek if current user is admin or owner
        - if it is can set 
    else
        dont have permission


=> if the room is dual room dont change anything


- create function change status of room , if is protected should create password , remove the password , change the password

=> return in first the staus of room
    - if wawnt to be protected should set a password


- create function return boolean value if leave the room or not


- when owner who create room if leave it
    - make the first admin added the owner
    - if this room dont have admin make first user the owner
 
- A user who is an administrator of a channel can kick, ban or mute (for a limited time) other users, but not the channel owners.


=> use try and catch here && search by id of user in db if found or not

- implement the leaveRoom



======================================================================================================================

- when admin or owner mute user this user cannot send message to the room who is muted rom it.

- implemt controller mute user .

- add boolean fild isMuted

- if is muted cannot send message , should wait after finish time of muted




 @SubscribeMessage('join-room') 
    @UsePipes(new ValidationPipe()) // Add the ValidationPipe here
    async joinRoom(@MessageBody() dto:JoinRoomDto) 
    { 

        try 
        {
            const user = this.jwtService.verify(dto.user,{ secret: process.env.JWT_SECRET })

            const currentUser = await this.utils.getUserId(user['sub']);

            if(!currentUser)
            {
                this.socketOfcurrentUser.emit('users-join','user not found.')
                return ;
            }
            
            const roomId:any = await this.utils.getRoomByName(dto.roomName);

            if(roomId)
            {
                const usersInRoom:any = await this.utils.getUsersInRooms(roomId.id);
                
                const find = usersInRoom.find((item:any) => item.userId === user['sub']);
    
                if(!find)
                {
                    const roomType = await this.utils.getRoomById(roomId.id);
                    const usersInroom = await this.utils.getUsersInRooms(roomId.id);                    
                    if(roomType.roomType === 'PROTECTED')
                    {
                        if(comparePasswd(dto.password,roomType.password) )
                        {
                            await this.roomService.linkBetweenUsersAndRooms(roomId.id, user['sub']);
                        
                        const usersInroom = await this.utils.getUsersInRooms(roomId.id);
                            
                            for(const userInRoom of usersInroom)
                            {
                                for (let i = 0; i < this.soketsId.length; i++) 
                                {
                                    if(this.soketsId[i].userId === userInRoom.userId)
                                    {
                                        this.server.to(this.soketsId[i].socketIds).emit('users-join', {roomId , userInfos: await this.utils.getUserInfosInRoom(roomId.id) , newUserAdded : usersInroom[usersInroom.length - 1] });                                    }
                                }

                            }
                            return ;
                        }
                        else
                        {
                            this.socketOfcurrentUser.emit('users-join',"password inccorect.")
                            return ;
                        }
                    }
                    else if(roomType.roomType === 'PUBLIC')
                    {
                        await this.roomService.linkBetweenUsersAndRooms(roomId.id, user['sub']);
                        
                        const usersInroom = await this.utils.getUsersInRooms(roomId.id);
                        
                        
                        // this.server.to(dto.socketId).emit('current-user-join', {roomId , userInfos: await this.utils.getUserInfosInRoom(roomId.id)});

                        for(const userInRoom of usersInroom)
                        {
                            for (let i = 0; i < this.soketsId.length; i++) 
                            {
                                if(this.soketsId[i].userId === userInRoom.userId)
                                {
                                    this.server.to(this.soketsId[i].socketIds).emit('users-join', {roomId , userInfos: await this.utils.getUserInfosInRoom(roomId.id) , newUserAdded : usersInroom[usersInroom.length - 1] });
                                }
                            }
  
                        } 
                        return ;
                    } 
                }
                else 
                {
                    // this.socketOfcurrentUser.emit('error-joinned-room','user aleredy in this room.')
                    this.OnWebSocektError(this.socketOfcurrentUser);
                }

            }
            else
            {
                // this.socketOfcurrentUser.emit('error-joinned-room','room not found.')
                this.OnWebSocektError(this.socketOfcurrentUser);

                return ;
            }
            
        } 
        catch (error : any) 
        {
            // this.socketOfcurrentUser.emit('error-joinned-room',error);
            // this.OnWebSocektError(this.socketOfcurrentUser);
        }
    }



 @Post()
    async createRoom(@Req() request: Request , @Body() dto:createRoom, @Res() res:any ,  @ConnectedSocket() socket: Socket)
    { 
        try 
        {
            const token = this.utils.verifyJwtFromHeader(request.headers['authorization']);

            if (token) 
            {
                const user = await this.utils.verifyToken(token)
              
                if (user) 
                {
                    const usersId = (await this.utils.getUsersIdByNickname(user['sub'],dto.users , 1)); // get ids of users 

                    if(usersId.error)
                        return res.status(404).send(usersId.error);

                    const ifUserExist = await this.utils.getUserId([user['sub'] , ...usersId.uniqUsers]);
                    
                    if(ifUserExist.error)
                        return res.status(404).send(ifUserExist.error);
                    
                    if (dto.type === RoomType.PRIVATE || dto.type === RoomType.PROTECTED || dto.type === RoomType.PUBLIC) 
                    {
                        if (dto.type === "PROTECTED") 
                        {
                            const room = await this.roomService.createRoom({roomName: dto.roomName, users: usersId.uniqUsers}, user['sub'], "PROTECTED", dto.password);
        
                            if(room === 1)
                            {
                                return res.status(406).send("room name aleredy exist.");
                            }
                            if(room === 0)
                            {
                                return res.status(406).send("should set password for this protected room.");
                            }
                            
                            res.status(200).send({room  , usersInRoom: await this.utils.getUsersInRooms(room['id']) , userInfos: await this.utils.getUserInfosInRoom(room['id'])});
                            
                        }
                        else
                        { 
                            const room = await this.roomService.createRoom({roomName: dto.roomName, users: usersId.uniqUsers}, user['sub'], dto.type);
        
                            if(room === 1)
                            {
                                return res.status(406).send("room name aleredy exist.");
                            }
        
                            res.status(200).send({room  , usersInRoom: await this.utils.getUsersInRooms(room['id']) , userInfos: await this.utils.getUserInfosInRoom(room['id'])});
                        }
                    }
                    else
                    {
                        return res.status(406).send("error in type of room.")
                    }

                }
            }
            else
            {
                return res.status(404).send('invalid jwt.')
            }
            

        } 
        catch (error) 
        {
            console.log('from createRoom()' )
         
            return res.status(500).json({ error: error.message });
        } 
    }