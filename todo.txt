- The channel owner is a channel administrator. They can set other users as administrators.


- before add users who want to be administrators:

=>  chcek if current user is admin or owner
        - if it is can set 
    else
        dont have permission


=> if the room is dual room dont change anything


- create function change status of room , if is protected should create password , remove the password , change the password

=> return in first the staus of room
    - if wawnt to be protected should set a password


- create function return boolean value if leave the room or not


- when owner who create room if leave it
    - make the first admin added the owner
    - if this room dont have admin make first user the owner
 
- A user who is an administrator of a channel can kick, ban or mute (for a limited time) other users, but not the channel owners.


=> use try and catch here && search by id of user in db if found or not

- implement the leaveRoom



======================================================================================================================

- when admin or owner mute user this user cannot send message to the room who is muted rom it.

- implemt controller mute user .

- add boolean fild isMuted

- if is muted cannot send message , should wait after finish time of muted





- test ban normal user for limmited time and forever.

- test when send message in room banned user not recsive it.

- test (postman) send message by banned user in room.

- test join to room first time.  *

- test if this user is banned from the room and want to join another time (in banned and unbanned). *

- test ban refresh time of banned.

- test try ban owner.

- test ban admin.

- test admin ban user.


=> when first time join room some time dont displayed on the page of new joined member.

=> hen banned user not removed from her page.

=> after user finish banned time,  send message other user not recsive the messages (should select to room name). (in this case owner cannot send the message)

=> emmit banned for ever











 const usersInroom = await this.utils.getUsersInRooms(rtn.room.id);
                                
    const leavedUser:any = await this.roomService.removeUserFromRoom(rtn.room.id, user['sub']);

let newOwner:any = await this.roomService.getFirstUser('ADMIN') // get first admin if found it


if(!newOwner) // if not found an admin
{
    newOwner = await this.roomService.getFirstUser('USER') // will search for the first user in the room

    await this.roomService.setNewOwner(rtn.room.id, newOwner.userId) // set first user in the room as owner
    // roomName and 
    
    
    // usersInroom.push(leavedUser.kickedUser);
    
    for(const userInRoom of usersInroom)
    {
        for (let i = 0; i < this.soketsId.length; i++) 
        {
            if(this.soketsId[i].userId === userInRoom.userId)
            {
                this.server.to(this.soketsId[i].socketIds).emit("onLeave",{ roomId: rtn.room , newOwner , leavedUser});
            } 
        }
    }
    
}
else
{
    // usersInroom.push(leavedUser.kickedUser);
        
    const newOwner_ = await this.roomService.setNewOwner(rtn.room.id, newOwner.userId) // set this first admin as the owne
    
    for(const userInRoom of usersInroom)
    {
        for (let i = 0; i < this.soketsId.length; i++) 
        {
            if(this.soketsId[i].userId === userInRoom.userId)
            {
                this.server.to(this.soketsId[i].socketIds).emit("onLeave",{ roomId: rtn.room , newOwner : newOwner_, leavedUser});
            } 
        }
    }

}