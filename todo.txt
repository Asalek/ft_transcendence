- The channel owner is a channel administrator. They can set other users as administrators.


- before add users who want to be administrators:

=>  chcek if current user is admin or owner
        - if it is can set 
    else
        dont have permission


=> if the room is dual room dont change anything


- create function change status of room , if is protected should create password , remove the password , change the password

=> return in first the staus of room
    - if wawnt to be protected should set a password


- create function return boolean value if leave the room or not


- when owner who create room if leave it
    - make the first admin added the owner
    - if this room dont have admin make first user the owner
 
- A user who is an administrator of a channel can kick, ban or mute (for a limited time) other users, but not the channel owners.


=> use try and catch here && search by id of user in db if found or not

- implement the leaveRoom



======================================================================================================================

- when admin or owner mute user this user cannot send message to the room who is muted rom it.

- implemt controller mute user .

- add boolean fild isMuted

- if is muted cannot send message , should wait after finish time of muted


 @Post('/setOtherAasAdministrators') // use dto
    async setOtherAasAdministrators(@Req() request: Request , @Body() dto:SetOtherAasAdministrators, @Res() res:any)
    {
        try 
        {
            const token = this.utils.verifyJwtFromHeader(request.headers['authorization']);

            if (token) 
            {
                const user = await this.utils.verifyToken(token)
              
                if (user) 
                {
                    const existingUsers = await this.utils.getUserId([user['sub'] , dto.newAdminId]); // if both users is is exist
        
                    if(existingUsers.error)
                        return res.status(404).send(existingUsers.error);
        
                    const roomId = await this.utils.getRoomIdByName(dto.roomName);
        
                    if(roomId)  
                    {
                        // here check if the both users in this room and cannot set same user as admin
                        const usersType = await this.utils.getUserType(roomId,existingUsers.existingUser);
                        
                        if(usersType.error)
                            return res.status(404).send(usersType.error);
                        
                        if(usersType.usersType[1].isBanned)
                        {
                            return res.status(404).send('you are banned.');
                        }
                        
                        if(usersType.usersType[0].userType !== 'USER') // if current user is admin or owner in this case can set admins
                        { 
                            // here before set admin check if it is aleredy admin or an  user
                            const rtn = await this.roomService.setNewAdmins(roomId, usersType.usersType[1]);

                            if(rtn.error)
                                return res.status(404).send(rtn.error);

                            return res.status(200).send(rtn.ok);
                        }

                        return res.status(404).send('dont have the permission to set an admin.');
                    }
                    return res.status(404).send('room not found.');
                }
            }    
            else
            {
                return res.status(404).send('invalid jwt.')
            }
        } 
        catch (error) 
        {
            console.log('from set()')
            return res.status(500).json({ error: error.message });
        }

    }






if(flag === 2)
                    {
                        const isBanned = await this.utils.ifUserIsBanned(existingUser.existingUser[1]);

                        if(isBanned[0].isBanned === 'BANNEDUNLIMMITED_TIME')
                        {
                            return {error : 'you are banned for life.'}
                        }
                        
                        return {room : roomId , usersType , existingUser };
                    }
                    
                    const isBanned = await this.utils.ifUserIsBanned(existingUser.existingUser[0]);
                    
                    if(!flag)
                    {
                        if(usersType.error)
                        {
                            return usersType;
                        }
                        
                        if(isBanned)
                        {
                            if(isBanned[0].isBanned === 'BANNEDFORLIMMITED_TIME')
                            {
                                if (isBanned[0].banExpiresAt <= new Date()) 
                                {
                                    await this.roomService.makeUserUnbanned(existingUser.existingUser[0], roomId.id); // make user unbanned
                                    return {ok : 'user is unbanned.'}
                                }
     
                                return {error : 'user is banned for limmited time.'}
                            }
                        }

                        return {room : roomId , usersType , existingUser };
                    }
                    else // for join room  and add new user to room because current user is not the room
                    {
                         
                        if(isBanned[0].isBanned === 'BANNEDFORLIMMITED_TIME')
                        {
                            if (isBanned[0].banExpiresAt <= new Date()) 
                            {
                                await this.roomService.makeUserUnbanned(existingUser.existingUser[0], roomId.id); // make user unbanned
                                return {ok : 'user is unbanned.'}
                            }
    
                            return {error : 'user is banned for limmited time.'}
                        }
                        return {room : roomId  , existingUser };
                    }